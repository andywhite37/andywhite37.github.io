<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Andy White</title>
    <link>https://andywhite.xyz/posts/</link>
    <description>Recent content in Posts on Andy White</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 07 Nov 2019 22:28:54 -0700</lastBuildDate>
    
	<atom:link href="https://andywhite.xyz/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>A Layman&#39;s Guide to Applicatives in ReasonML</title>
      <link>https://andywhite.xyz/posts/2019-11-07-a-laymans-guide-to-applicatives-in-reasonml/</link>
      <pubDate>Thu, 07 Nov 2019 22:28:54 -0700</pubDate>
      
      <guid>https://andywhite.xyz/posts/2019-11-07-a-laymans-guide-to-applicatives-in-reasonml/</guid>
      <description>Other posts in this series:  A Layman&#39;s Guide to Functors in ReasonML  Applicative functors I&#39;ll start this post off with a tantalizing quote that I first heard from a former colleague/mentor Kris Nuttycombe:
 In functional programming, applicatives are the essence of parallel processing, and monads are the essence of sequential processing.
 In this post about applicative functors (aka applicatives), and my next planned post about monads, I hope to dig into this notion, and try to impart some intuition as to why this is true.</description>
    </item>
    
    <item>
      <title>A Layman&#39;s Guide to Functors in ReasonML</title>
      <link>https://andywhite.xyz/posts/2019-11-01-a-laymans-guide-to-functors-in-reasonml/</link>
      <pubDate>Fri, 01 Nov 2019 17:50:46 -0600</pubDate>
      
      <guid>https://andywhite.xyz/posts/2019-11-01-a-laymans-guide-to-functors-in-reasonml/</guid>
      <description>In my intro post I talked about my background and how I started on my journey to learn typed functional programming. I&#39;ll again preface these posts with a note that I don&#39;t have a background in category theory, so these posts are intended to help introduce things from a boots-on-the-ground perspective. Please feel free to correct me on any points I&#39;ve messed up. I&#39;m also not an OCaml expert, so there may be techniques or coding conventions here that are not completely correct.</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://andywhite.xyz/posts/2019-10-31-hello-world/</link>
      <pubDate>Thu, 31 Oct 2019 21:11:53 -0600</pubDate>
      
      <guid>https://andywhite.xyz/posts/2019-10-31-hello-world/</guid>
      <description>The world of typed functional programming is a vast, mind-blowing, and often terrifying place. There are so many things to learn and so many rabbit holes to go down, it&#39;s easy to get overwhelmed, and not know where to even start. For most of my software development career, I operated in blissful ignorance of functional programming - I happily wrote object-oriented and imperative code, mutating data and throwing all sorts of exceptions, and I was actually pretty content with it.</description>
    </item>
    
  </channel>
</rss>