<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Andy White">
    <meta name="description" content="Andy White&#39;s personal website">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="A Layman&#39;s Guide to Functors in ReasonML"/>
<meta name="twitter:description" content="In my intro post I talked about my background and how I started on my journey to learn typed functional programming. I&rsquo;ll again preface these posts with a note that I don&rsquo;t have a background in category theory, so these posts are intended to help introduce things from a boots-on-the-ground perspective. Please feel free to correct me on any points I&rsquo;ve messed up. I&rsquo;m also not an OCaml expert, so there may be techniques or coding conventions here that are not completely correct."/>

    <meta property="og:title" content="A Layman&#39;s Guide to Functors in ReasonML" />
<meta property="og:description" content="In my intro post I talked about my background and how I started on my journey to learn typed functional programming. I&rsquo;ll again preface these posts with a note that I don&rsquo;t have a background in category theory, so these posts are intended to help introduce things from a boots-on-the-ground perspective. Please feel free to correct me on any points I&rsquo;ve messed up. I&rsquo;m also not an OCaml expert, so there may be techniques or coding conventions here that are not completely correct." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://andywhite.xyz/blog/2019-11-01-a-laymans-guide-to-functors-in-reasonml/" />
<meta property="article:published_time" content="2019-11-01T17:50:46-06:00" />
<meta property="article:modified_time" content="2019-11-01T17:50:46-06:00" />


    
      <base href="https://andywhite.xyz/blog/2019-11-01-a-laymans-guide-to-functors-in-reasonml/">
    
    <title>
  A Layman&#39;s Guide to Functors in ReasonML Â· Andy White
</title>

    
      <link rel="canonical" href="https://andywhite.xyz/blog/2019-11-01-a-laymans-guide-to-functors-in-reasonml/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://andywhite.xyz/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    
    
    <link rel="icon" type="image/png" href="https://andywhite.xyz/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://andywhite.xyz/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.58.3" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://andywhite.xyz/">
      Andy White
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://andywhite.xyz/blog/">Blog</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://andywhite.xyz/projects/">Projects</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://andywhite.xyz/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>A Layman&#39;s Guide to Functors in ReasonML</h1>
    </header>

    

<p>In <a href="https://andywhite.xyz/blog/2019-10-31-hello-world">my intro post</a> I talked about my background
and how I started on my journey to learn typed functional programming. I&rsquo;ll
again preface these posts with a note that I don&rsquo;t have a background in
category theory, so these posts are intended to help introduce things from a
boots-on-the-ground perspective. Please feel free to correct me on any points
I&rsquo;ve messed up. I&rsquo;m also not an OCaml expert, so there may be techniques or
coding conventions here that are not completely correct. The purpose of these
blogs is not to achieve rigorous perfection but to help impart some intuition
on the topics. If you find any issues with code examples, please let me know,
and I&rsquo;ll fix them.</p>

<h1 id="functors">Functors</h1>

<p>In this post, I would like to talk about functors - not <a href="https://v1.realworldocaml.org/v1/en/html/functors.html">OCaml/ReasonML
module functors</a>, but
functors as they relate to the <code>map</code> function. I would wager that most
software developers have probably used a <code>map</code> function for lists or arrays,
and probably a map-like function when dealing with asynchronous types like
<code>Future</code> or <code>Promise</code>, to convert a value of some type <code>A</code> to a value of some
other type <code>B</code>. If you&rsquo;re lucky, you&rsquo;ve used <code>map</code> on a type like <code>Option</code>,
<code>Maybe</code>, <code>Either</code> or <code>Result</code>. If you&rsquo;re really blessed, maybe you&rsquo;ve used it
in something like a JSON decoder function to transform a decoded number into
some other type.</p>

<h1 id="reasonml-a-quick-aside">ReasonML - a quick aside</h1>

<p>I&rsquo;m going to use the language <a href="https://reasonml.github.io">ReasonML</a> for
these posts, not because it&rsquo;s the most powerful language around (it&rsquo;s not),
but because it provides an interesting platform on which to build up some
examples. If you&rsquo;re not familiar with ReasonML, it&rsquo;s basically an alternative
syntax for the programming language <a href="https://ocaml.org">OCaml</a>. The ReasonML
programming language can be losslessly translated to OCaml and vice-versa,
because the two languages share the same <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree
(AST)</a> - the data
structure that represents the parsed code.</p>

<p>One of the reasons ReasonML was created was to provide a syntax that would be
more familiar to developers coming from JavaScript/ECMAScript. ReasonML has a
few different compilers which are able to produce JavaScript as a &ldquo;backend,&rdquo;
meaning that it can transpile ReasonML (or OCaml) code to JavaScript, for use
in the browser, or in Node.js, for example. The compiler I most use at the
moment is called <a href="https://bucklescript.github.io/en/">BuckleScript</a>, which is
actually specifically an OCaml to JS compiler. To make it work with ReasonML,
you use a separate tool to translate the ReasonML code to OCaml code before
compiling it with the BuckleScript compiler to produce the JavaScript output,
which you then have to bundle with a tool like <a href="https://webpack.js.org">Webpack
ðŸ˜±</a>, <a href="https://parceljs.org">Parcel</a>,
<a href="https://rollupjs.org/guide/en/">Rollup</a> or whatever the latest
<em>so hot right now</em> bundler happens to be in the JavaScript community.</p>

<p>The workflow is basically:</p>

<ol>
<li>Write ReasonML code</li>
<li>Convert ReasonML code to OCaml</li>
<li>Compile OCaml code with BuckleScript to produce JavaScript code</li>
<li>Bundle JavaScript code to produce something you can use on the web or in Node.js</li>
</ol>

<p>If this sounds a little crazy to you, you&rsquo;re right, it is a little crazy.
However steps 2 and 3 kind of happen at the same time by the same tool, and
the BuckleScript compiler is blazing fast, so if you&rsquo;re writing ReasonML, you
really don&rsquo;t see OCaml code at all, and the JavaScript that comes out the
other end is quite readable and usually pretty optimized. Overall, there is
some weight of tooling with this, but the installation of these tools have
been mostly ironed out, and are improving each day.</p>

<p>As a side note, you can also compile ReasonML code to native code using the
native OCaml compiler and tools like <a href="https://esy.sh">esy</a> or
<a href="https://github.com/ocaml/dune">dune</a>. I don&rsquo;t have any experience with these
native tools, so I won&rsquo;t say anymore about that.</p>

<h1 id="shameless-plug">Shameless plug</h1>

<p>As a side note, I currently work on a set of libraries for
ReasonML/BuckleScript in the <a href="https://github.com/reazen">Reazen GitHub org</a>.
Our core &ldquo;standard library replacement&rdquo; library is called
<a href="https://github.com/reazen/relude">Relude</a>, and there are a growing number of
other libraries built on top of Relude. Many of the ideas from these blog
posts can be seen in action in Relude, and it&rsquo;s underlying library
<a href="https://github.com/Risto-Stevcev/bs-abstract">bs-abstract</a>, so check them
out if you are interested. Also, I&rsquo;ll re-emphasize that most of the ideas in
Relude are not our own - they come from the rich history and ecosystem of
typed pure functional programming.</p>

<h1 id="back-to-functors">Back to functors</h1>

<p>To jump right in, I&rsquo;m going to introduce one way to represent a functor in
ReasonML and then go from there. In ReasonML, we have the concept of
<a href="https://ocaml.org/learn/tutorials/modules.html">modules</a>, which are a
fundamental and first-class structure in the language. You can think
of modules as being structural and organizational, like a namespace, but
modules can also be passed to functions as a first-class construct in the
language. You can construct modules from other modules using <a href="https://v1.realworldocaml.org/v1/en/html/functors.html">module
functors</a>, but as a
reminder, these are not the functors we&rsquo;re talking about in this blog. You
can also create <a href="https://ocaml.org/learn/tutorials/modules.html">module
types</a>, which sort of act as
a way to describe an &ldquo;interface&rdquo; for a module. If none of these words mean
anything to you, I&rsquo;d recommend reading some more about OCaml or ReasonML
modules before continuing, otherwise this might quickly become confusing and
unfamiliar.</p>

<p>A functor has a couple key properties which we can encode in ReasonML using a
module type. One key aspect of a functor is that it deals with types that
have a single type parameter, e.g.</p>

<ul>
<li><code>list('a)</code></li>
<li><code>array('a)</code></li>
<li><code>option('a)</code>,</li>
<li><code>Js.Promise.t('a)</code></li>
<li><code>Belt.Result.t('a, fixedErrorType)</code> if the error type is fixed to a known type</li>
<li>and many others, both generic and domain-specific</li>
</ul>

<p>In general, we&rsquo;ll just call types of this form <code>t('a)</code>.</p>

<p>The next requirement of a functor is that it must support a <code>map</code> function
with the following type signature:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">);</span></code></pre></div>
<p>Basically, <code>map</code> is a function that accepts an <code>'a =&gt; 'b</code> function to convert
a value of type <code>'a</code> to a value of type <code>'b</code>, a value of type <code>t('a)</code>, and
returns to you a value of type <code>t('b)</code>.</p>

<p>Another way to look at <code>map</code> is that it takes a function of type <code>'a =&gt; 'b</code>
and returns to you a function of type <code>t('a) =&gt; t('b)</code>. ReasonML is a
<a href="https://en.wikipedia.org/wiki/Currying">curried language</a>, so it&rsquo;s often
useful to think about <a href="https://en.wikipedia.org/wiki/Partial_application">partially
applying</a> arguments. In
this example, if we partially apply the <code>'a =&gt; 'b</code> function in <code>map</code>, we are
left with a function from <code>t('a) =&gt; t('b)</code>. This function looks a lot like
<code>'a =&gt; 'b</code>, but &ldquo;lifted&rdquo; into our functor context.</p>

<p>The order of the arguments to our <code>map</code> function doesn&rsquo;t really matter, and
neither does the name of the function - the important parts are the <strong>types</strong>
of the arguments and return value. We could use the following type instead,
and it would still be the the same concept:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> foo <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">),</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">);</span></code></pre></div>
<p>Another thing you&rsquo;ll commonly see in FP is the manipulation of function args,
like using a <code>flip</code> function to turn a function <code>('a, 'b) =&gt; 'c</code> to <code>('b, 'a)
=&gt; 'c</code>.</p>

<h1 id="aside-on-names">Aside on names</h1>

<p>A very common complaint about learning functional programming is that the
names of things just don&rsquo;t really have much semantic meaning. Many of the
names come from cateogry theory and abstract algebra, and sometimes the names
of the mathematicians who discovered or developed the concepts. I&rsquo;ve seen
lots of posts and comments on the internet about how we should call this
&ldquo;functor thing&rdquo; <code>Mappable</code> rather than <code>Functor</code>, because <code>Mappable</code> has a
more intuitive and semantic meaning. This is a fair complaint and suggestion,
but it starts to break down a bit when we start to get into more abstract and
powerful concepts.</p>

<p>The most important aspect of a name is that it gives us a way to refer to a
concept in its entirety using one or two distinct words. The same argument
for a common language was made in the venerable OO <a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_3?keywords=design+patterns&amp;qid=1572666058&amp;sr=8-3">Design
Patterns</a>
book, <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=asc_df_0321125215/?tag=hyprod-20&amp;linkCode=df0&amp;hvadid=312118197030&amp;hvpos=1o1&amp;hvnetw=g&amp;hvrand=11366912520175513035&amp;hvpone=&amp;hvptwo=&amp;hvqmt=&amp;hvdev=c&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=9028890&amp;hvtargid=pla-449269547899&amp;psc=1">Domain-Driven
Design</a>,
and just about every branch of learning from mathematics and science to law
and history.</p>

<p>There was once a time where the word &ldquo;Integer&rdquo; probably didn&rsquo;t mean anything
to you, but as you learned about the definition of an integers, and what you
can do with them, the abstract name became associated with the concrete
concept, and now we use the term <code>int</code> without a second thought, knowing
exactly what it is. I would go so far to say that something that was once
completely unknown is now viewed by most as simple and obvious. Someone might
have proposed that we call these things &ldquo;Addables&rdquo; or &ldquo;Operatables&rdquo; or
whatever to give it a more semantic (though insufficient) name, but
ultimately, once you learn what the name denotes, the name really doesn&rsquo;t end
up mattering anymore, and it&rsquo;s often more difficult to capture the full
semantics in a single semantic name anyway.</p>

<p>This is not to say that names don&rsquo;t matter, but it&rsquo;s quite common in FP for
concepts to have abstract names, and for some functions to have opaque
operators. This will require some learning and patience, and it&rsquo;s just
something you&rsquo;ll have to get used to. That said, I&rsquo;ve experienced the
firehose of unknown words, so I&rsquo;m not trying to brush this off, but just
trying to set expectations. Just remember, you don&rsquo;t have to understand all
of this at once! Just to try build up, cement, and apply your knowledge over
time, and it will grow.</p>

<h1 id="functor-laws">Functor laws</h1>

<p>We now know that a functor deals with a type <code>t('a)</code> and has a function <code>map</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">);</span>
<span style="color:#66d9ef">let</span> map<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">);</span></code></pre></div>
<p>There are two additional things that we must satisfy in order for something to
be considered a valid functor: the &ldquo;functor laws.&rdquo;</p>

<h2 id="first-functor-law-structure-preserving-map">First functor law - structure preserving map</h2>

<p>The first law requires that the <code>map</code> function cannot change the structure of
the data type - it can only change the values contained within the functor
using the <code>'a =&gt; 'b</code> function. This is sometimes called a
&ldquo;structure-preserving&rdquo; map operation.</p>

<p>The first functor law can be written like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">//</span> <span style="color:#a6e22e">The</span> identity <span style="color:#66d9ef">function</span> <span style="color:#f92672">-</span> simply returns the <span style="color:#66d9ef">value</span> given <span style="color:#66d9ef">as</span> the argument
<span style="color:#66d9ef">let</span> id <span style="color:#f92672">=</span> a <span style="color:#f92672">=&gt;</span> a<span style="color:#f92672">;</span>

<span style="color:#f92672">//</span> <span style="color:#a6e22e">The</span> <span style="color:#f92672">===</span> here just means these things must be the same
map<span style="color:#f92672">(</span>id<span style="color:#f92672">,</span> fa<span style="color:#f92672">)</span> <span style="color:#f92672">===</span> fa<span style="color:#f92672">;</span></code></pre></div>
<p>Basically if you map the identity function over your functor, you should get
back your functor completely unchanged, both in content and structure. In
concrete terms, the <code>map</code> function for <code>list('a)</code> (or any other functor) is
not allowed to shuffle things around, copy values, lengthen (create new
structure), nor shorten (remove structure) the list, etc.</p>

<p>This concept is important, because if you have a valid functor, you can be
confident that the <code>map</code> operation will only apply the given function to each
value contained within your functor, and will not change the structure of your
data type.</p>

<h2 id="second-functor-law-composition">Second functor law - composition</h2>

<p>The second functor law has to do with function composition. Basically, if you have
a functor <code>t('a)</code>, and two functions that you&rsquo;d like to map:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> fa<span style="color:#f92672">:</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">...;</span>

<span style="color:#66d9ef">let</span> aToB<span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b <span style="color:#f92672">=</span> <span style="color:#f92672">...;</span>

<span style="color:#66d9ef">let</span> bToC<span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>b <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>c <span style="color:#f92672">=</span> <span style="color:#f92672">...;</span></code></pre></div>
<p>We can create two specialized map functions by <a href="https://en.wikipedia.org/wiki/Partial_application">partially
applying</a> our <code>aToB</code> and
<code>bToC</code> functions to <code>map</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> mapAToB<span style="color:#f92672">:</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> map<span style="color:#f92672">(</span>aToB<span style="color:#f92672">);</span>

<span style="color:#66d9ef">let</span> mapBToC<span style="color:#f92672">:</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> map<span style="color:#f92672">(</span>bToC<span style="color:#f92672">);</span></code></pre></div>
<p>This is an example of &ldquo;lifting&rdquo; our pure <code>'a =&gt; 'b</code> functions into the
functor context <code>t('a) =&gt; t('b)</code>.</p>

<p>Now let&rsquo;s <a href="https://en.wikipedia.org/wiki/Function_composition">compose</a> these
two functions to create a function from <code>t('a) =&gt; t('c)</code>. First let create a
helper function and operator that we can use for composing functions:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> andThen<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>b <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>aToB<span style="color:#f92672">,</span> bToC<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">=&gt;</span> bToC<span style="color:#f92672">(</span>aToB<span style="color:#f92672">(</span>a<span style="color:#f92672">));</span>

<span style="color:#66d9ef">let</span> <span style="color:#f92672">(&gt;&gt;)</span> <span style="color:#f92672">=</span> andThen<span style="color:#f92672">;</span></code></pre></div>
<p>Now we can create a function from <code>t('a) =&gt; t('c)</code> by composing our functions <code>t('a) =&gt; t('b)</code>
and <code>t('b) =&gt; t('c)</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> mapAToC<span style="color:#f92672">:</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> mapAToB <span style="color:#f92672">&gt;&gt;</span> mapBToC<span style="color:#f92672">;</span></code></pre></div>
<p>Ok, so we&rsquo;ve composed our two specialized map functions into a specialized map function that
does both map operations.  Now let&rsquo;s try composing our <code>'a =&gt; 'b</code> and <code>'b =&gt; 'c</code> functions:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> aToC<span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>c <span style="color:#f92672">=</span> aToB <span style="color:#f92672">&gt;&gt;</span> bToC<span style="color:#f92672">;</span></code></pre></div>
<p>Now apply that <code>'a =&gt; 'c</code> function to our map, creating our function <code>t('a) =&gt; t('c)</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> mapAToC<span style="color:#f92672">:</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> map<span style="color:#f92672">(</span>aToC<span style="color:#f92672">);</span></code></pre></div>
<p>We&rsquo;ve now created two versions of the function <code>t('a) =&gt; t('c)</code> - one version
by composing two specialized partial-applications of <code>map</code>, and one using a
composed function within <code>map</code>. The second law states that these two
specialized <code>t('a) =&gt; t('c)</code> functions must be equal. In other words (<code>===</code>
just means these things are equal):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">map<span style="color:#f92672">(</span>aToB<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;&gt;</span> map<span style="color:#f92672">(</span>bToC<span style="color:#f92672">)</span> <span style="color:#f92672">===</span> map<span style="color:#f92672">(</span>aToB <span style="color:#f92672">&gt;&gt;</span> bToC<span style="color:#f92672">)</span></code></pre></div>
<p>This is probably confusing (and poorly explained), but basically what it
means is that mapping one function <code>f</code>, then mapping another function <code>g</code>
over a functor in two passes should the same as mapping the composed function
<code>f &gt;&gt; g</code> over the functor in a single pass. This law is important in that if
we have a valid functor, we know that we can make a pretty substantial
optimization - rather than mapping two different functions over our functor
in two passes, we can do the same thing in a single pass by composing the
functions.</p>

<h2 id="why-the-laws-matter">Why the laws matter</h2>

<p>The laws exist to make sure we have a concrete definition as to what makes a
functor a functor. Unfortunately, we can&rsquo;t easily express these laws via the
ReasonML type system, and this is a common problem with many FP languages. A
common solution to this shortfall is to use a <a href="https://dev.to/jdsteinhauser/intro-to-property-based-testing-2cj8">property-based
testing</a>
library like <a href="https://github.com/Risto-Stevcev/bs-jsverify">bs-jsverify</a>.
This style of testing basically has you setup &ldquo;properties&rdquo; of a type, like
the functors laws for example, and then the test framework will test that
property or law against your implementation using a set of generated inputs
to ensure that it passes the law in all cases. I hope to give a more concrete
example of this in a future blog post.</p>

<h1 id="the-functor-typeclass-module-type">The FUNCTOR typeclass (module type)</h1>

<p>Let&rsquo;s acknowledge that the laws are critically important, but we&rsquo;re going to
just file them away for now, and return to more concrete things. Below is how
you might <strong>actually</strong> define a functor as a ReasonML module type (remember
that module types are sort of like interfaces for actual concrete modules):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FUNCTOR</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">);</span>
  <span style="color:#66d9ef">let</span> map<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">);</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>I&rsquo;m going to use all-caps for our module types to differentiate them from the
actual implementation modules. In FP languages like Haskell, PureScript, and
Scala (among others), this interface concept is called a &ldquo;typeclass&rdquo; and the
implementation concept is called an &ldquo;instance of the typeclass&rdquo; or just
&ldquo;instance.&rdquo; So we can say that <code>FUNCTOR</code> is our &ldquo;typeclass module type,&rdquo; and
the things we&rsquo;re going to implement below are our &ldquo;instances&rdquo; of our
typeclass. You might notice that a typeclass is similar in concept to an OO
interface, and in some ways they are. One key difference is that your
implementation &ldquo;instance&rdquo; is a standalone module or value and is not tied to
a another &ldquo;host&rdquo; type like it would be in an OO language where your functor
type might do something like <code>class List extends Functor</code>. In some ways an
instance might be closer to the OO <a href="https://en.wikipedia.org/wiki/Adapter_pattern">adapter
patter</a>, but still a little
different.</p>

<p>Let&rsquo;s make a few quick observations about this <code>FUNCTOR</code> typeclass. In order
to provide an implementation of this &ldquo;interface,&rdquo; we must:</p>

<ol>
<li>Specify a type with a single type parameter <code>t('a)</code></li>
<li>Provide a <code>map</code> function that conforms to the given type</li>
<li>Implicitly follow the functor laws in our implementation of <code>map</code>, as they
are not guaranteed by the types alone</li>
</ol>

<p>With this type <code>t('a)</code> and this <code>map</code> function, let&rsquo;s also notice that a
<code>FUNCTOR</code> does not give you any way to put a value of type <code>'a</code> into your
functor. It also doesn&rsquo;t know how to construct a value of type <code>'a</code>. Finally
it doesn&rsquo;t know how to do other things like flattening a <code>t(t('a))</code> into a
<code>t('a)</code>, adding structure like turning a <code>t('a)</code> into a <code>t(t('a))</code>, etc. All
it knows how to do is apply a pure function <code>'a =&gt; 'b</code> to each value &lsquo;<code>a</code> in
<code>t('a)</code> to produce a value of type <code>t('b)</code>. (It can&rsquo;t produce values of type
<code>'b</code> out of thin air either - it doesn&rsquo;t know or care what types <code>'a</code> and
<code>'b</code> are!).</p>

<h1 id="list-functor">List functor</h1>

<p>Now let&rsquo;s implement <code>FUNCTOR</code> for <code>list('a)</code>. These implementations are purely
for demonstration purposes, so no attempt is made to optimize anything. I&rsquo;m going
to follow a convention of creating a wrapper module named after my main type, like
<code>module List</code>, then implement a few things within this module, then finally implement
my <code>Functor</code> as a nested submodule of <code>List</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">List</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#f92672">//</span> <span style="color:#a6e22e">Alias</span> our <span style="color:#66d9ef">type</span><span style="color:#f92672">,</span> so we can use <span style="color:#f92672">`</span>List.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)`</span> <span style="color:#f92672">and</span> <span style="color:#f92672">`</span><span style="color:#66d9ef">list</span><span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)`</span> interchangably

  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">list</span><span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">);</span>

  <span style="color:#f92672">//</span> <span style="color:#a6e22e">Implement</span> our map <span style="color:#66d9ef">function</span>
  <span style="color:#f92672">//</span> <span style="color:#a6e22e">This</span> implementation is recursive<span style="color:#f92672">,</span> so we&#39;re using <span style="color:#f92672">`</span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span><span style="color:#f92672">`</span>

  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> map <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">,</span> <span style="color:#66d9ef">list</span><span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> switch<span style="color:#f92672">(</span><span style="color:#66d9ef">list</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">|</span> [] <span style="color:#f92672">=&gt;</span> []
    <span style="color:#f92672">|</span> <span style="color:#f92672">[</span>head<span style="color:#f92672">,</span> <span style="color:#f92672">...</span>tail<span style="color:#f92672">]</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">[</span>f<span style="color:#f92672">(</span>head<span style="color:#f92672">),</span> map<span style="color:#f92672">(</span>f<span style="color:#f92672">,</span> tail<span style="color:#f92672">)]</span>
  <span style="color:#f92672">};</span>

  <span style="color:#f92672">//</span> <span style="color:#a6e22e">Now</span> <span style="color:#66d9ef">let&#39;</span>s define our <span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">as</span> a <span style="color:#66d9ef">module</span> that implements our <span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FUNCTOR</span>

  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Functor</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">//</span> <span style="color:#a6e22e">Here</span> we just define the members <span style="color:#66d9ef">of</span> the <span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span>
    <span style="color:#f92672">//</span> <span style="color:#a6e22e">We</span> use nonrec here so the compiler knows we&#39;re not trying <span style="color:#66d9ef">to</span> define
    <span style="color:#f92672">//</span> a recursive <span style="color:#66d9ef">type</span> here<span style="color:#f92672">,</span> but that the t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> on the right side refers
    <span style="color:#f92672">//</span> <span style="color:#66d9ef">to</span> the t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> defined above<span style="color:#f92672">.</span>

    <span style="color:#66d9ef">type</span> nonrec t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> map<span style="color:#f92672">;</span>
  <span style="color:#f92672">};</span>

  <span style="color:#f92672">//</span> <span style="color:#a6e22e">Another</span> way <span style="color:#66d9ef">to</span> define this without using our <span style="color:#f92672">`</span><span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">list</span><span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)`</span> alias would be<span style="color:#f92672">:</span>

  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Functor</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">list</span><span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">list</span><span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> map<span style="color:#f92672">;</span>
  <span style="color:#f92672">};</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>The <code>module Functor: FUNCTOR</code> part is saying that we intend for our module
to implement the <code>FUNCTOR</code> module type, and we want the compiler to check this
for us. You can leave off the <code>: FUNCTOR</code>, and the compiler should be able to
infer this.</p>

<p>The <code>with type t('a) = list('a)</code> business is a mechanism for exposing
information about the types contained in our module to the outside world. To
be honest, I&rsquo;m not an expert on OCaml modules and how they interact with
types, so I won&rsquo;t attempt to explain any of this, but just know that it&rsquo;s
important in this case for the outside world to know that the type <code>t('a)</code>
inside our <code>List.Functor</code> is the same type as (an alias of) <code>list('a)</code>.</p>

<p>Now we have a module <code>List.Functor</code> which conforms to the interface defined
by the <code>FUNCTOR</code> module type. In other words, <code>List.Functor</code> is an instance
of the typeclass <code>FUNCTOR</code>. And in OCaml/ReasonML modules are &ldquo;first-class,&rdquo;
so we can actually pass this <code>List.Functor</code> module around as a value, and use
it in places that want to operate on <code>FUNCTOR</code>s.</p>

<p>Also, while we are not attempting to prove that our implementation conforms
to the functor laws above, you can sort of intuitively tell that it conforms
to the first functor law (mapping identity) by just looking. The <code>'a =&gt; 'b</code>
function is applied to the head value, then the <code>map</code> function is called
recursively to apply the function to the tail list. Nothing is being done to
shuffle values around, copy them, etc. and if you were to pass the <code>id: 'a =&gt;
'a</code> function to our <code>map</code>, it&rsquo;s pretty clear the list would not be modified.
The composition law is a little harder to see intuitively, so we&rsquo;ll just
ignore it for now.</p>

<h1 id="aside-on-learning-this">Aside on learning this</h1>

<p>Now that we&rsquo;ve seen how to implement a <code>FUNCTOR</code> for <code>list('a)</code> (and how easy
it is!), I&rsquo;d recommend trying to implement functor for some of the types
below yourself - I found it was very helpful to learn this stuff by going
through the motions myself, rather than just reading.</p>

<h1 id="array-functor">Array functor</h1>

<p>The <code>array('a)</code> type has a functor, but it&rsquo;s basically exactly the same as
<code>list('a)</code>, so I&rsquo;m going to skip over it. The only real difference is how
<code>map</code> is implemented (just because <code>list('a)</code> and <code>array('a)</code> are different
types), so if you want to give it a shot, go for it!</p>

<h1 id="option-functor">Option functor</h1>

<p>Now let&rsquo;s implement <code>FUNCTOR</code> for <code>option('a)</code>. I&rsquo;m going to follow the convention
of defining a wrapper module for the main type, and aliasing the type <code>t('a)</code>, then
defining the <code>Functor</code> as a nested submodule of our main module.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Option</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> option<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">);</span>

  <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">,</span> option<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> switch<span style="color:#f92672">(</span>option<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Some</span><span style="color:#f92672">(</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Some</span><span style="color:#f92672">(</span>f<span style="color:#f92672">(</span>a<span style="color:#f92672">))</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">None</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">None</span>
  <span style="color:#f92672">};</span>

  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Functor</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">type</span> nonrec t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">);</span> <span style="color:#f92672">//</span> alias above <span style="color:#66d9ef">type</span>
    <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> map<span style="color:#f92672">;</span> <span style="color:#f92672">//</span> alias above map <span style="color:#66d9ef">function</span>
  <span style="color:#f92672">};</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>An <code>option('a)</code> is basically a list of 0 or 1 items, so the implementation is
super easy. Once again, the first functor law can be seen intuitively.</p>

<p>Hopefully at this point, if functors were scary before, they are very un-scary
now. Maybe functors were never that scary to begin with&hellip;</p>

<h1 id="result-functor">Result functor</h1>

<p><code>Belt.Result.t('a, 'e)</code> is our first example type that doesn&rsquo;t exactly fit
the <code>t('a)</code> requirement of functor. We can easily implement <code>map</code> as a
function, because we can just ignore the error <code>'e</code> case, and only map the
success <code>'a</code> case, but the <code>Functor</code> module is not quite as straightforward.</p>

<p>Below is the initial cut at implementing <code>map</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Result</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>e<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Ok</span><span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Error</span><span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>e<span style="color:#f92672">);</span>

  <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">,</span> fa<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> switch<span style="color:#f92672">(</span>fa<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Ok</span><span style="color:#f92672">(</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Ok</span><span style="color:#f92672">(</span>f<span style="color:#f92672">(</span>a<span style="color:#f92672">));</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Error</span><span style="color:#f92672">(</span>e<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Error</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
  <span style="color:#f92672">};</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>As you can see, in the <code>map</code> function, we just ignore the error side, and
only apply the function to our <code>Ok(a)</code> value.</p>

<p>Now we want to implement <code>FUNCTOR</code>, but we&rsquo;re immediately going to run into a
problem - <code>FUNCTOR</code> wants us to give it a <code>t('a)</code> - so what do we do with
this error type <code>'e</code>?</p>

<p>One way to implement this is to create a very simple <code>module type</code> which
simply acts to specify a type, then to use a ReasonML <a href="https://v1.realworldocaml.org/v1/en/html/functors.html">module
functor</a> (reminder
that &ldquo;module functors&rdquo; are more like &ldquo;module functions&rdquo; or &ldquo;module
constructors&rdquo;, and not the map functors we&rsquo;re talking about in this article)
to make our <code>Result</code> functor a function of some error type, at the module
level. This is a little funky, especially coming from other non-module-based
languages, but hopefully it makes sense in a simple example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">//</span> <span style="color:#a6e22e">Create</span> a super simple <span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#f92672">`</span><span style="color:#a6e22e">TYPE</span><span style="color:#f92672">`</span> which just acts <span style="color:#66d9ef">to</span> capture a <span style="color:#66d9ef">type</span> <span style="color:#f92672">`</span>t<span style="color:#f92672">`</span>
<span style="color:#f92672">//</span> <span style="color:#a6e22e">This</span> can live outside our <span style="color:#f92672">`</span><span style="color:#a6e22e">Result</span><span style="color:#f92672">`</span> <span style="color:#66d9ef">type</span><span style="color:#f92672">:</span>

<span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TYPE</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">;</span>
<span style="color:#f92672">};</span>

<span style="color:#f92672">//</span> <span style="color:#a6e22e">Now</span> we can setup a <span style="color:#66d9ef">module</span> <span style="color:#66d9ef">functor</span> <span style="color:#66d9ef">to</span> allow us <span style="color:#66d9ef">to</span> construct a <span style="color:#f92672">`</span><span style="color:#a6e22e">FUNCTOR</span><span style="color:#f92672">`</span>
<span style="color:#f92672">//</span> <span style="color:#66d9ef">for</span> a given error <span style="color:#66d9ef">type</span><span style="color:#f92672">,</span> specified by a <span style="color:#a6e22e">TYPE</span> <span style="color:#66d9ef">module</span><span style="color:#f92672">:</span>

<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Result</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>e<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Ok</span><span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Error</span><span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>e<span style="color:#f92672">);</span>

  <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">,</span> result<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> switch<span style="color:#f92672">(</span>result<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Ok</span><span style="color:#f92672">(</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Ok</span><span style="color:#f92672">(</span>f<span style="color:#f92672">(</span>a<span style="color:#f92672">));</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Error</span><span style="color:#f92672">(</span>e<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Error</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
  <span style="color:#f92672">};</span>

  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">MakeFunctor</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">E</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">TYPE</span><span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">//</span> <span style="color:#a6e22e">Here</span> we reference our above Result.t<span style="color:#f92672">,</span> but <span style="color:#66d9ef">with</span> the error <span style="color:#66d9ef">type</span> <span style="color:#e6db74">&#34;locked-in&#34;</span>
    <span style="color:#f92672">//</span> <span style="color:#66d9ef">to</span> the <span style="color:#66d9ef">type</span> given <span style="color:#66d9ef">to</span> us by <span style="color:#f92672">`</span><span style="color:#a6e22e">E</span><span style="color:#f92672">`</span> <span style="color:#f92672">-</span> which is a <span style="color:#66d9ef">module</span> conforming <span style="color:#66d9ef">to</span> the <span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#f92672">`</span><span style="color:#a6e22e">TYPE</span><span style="color:#f92672">`</span>

    <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> E.t<span style="color:#f92672">);</span>

    <span style="color:#f92672">//</span> <span style="color:#a6e22e">The</span> map <span style="color:#66d9ef">function</span> just works regardless <span style="color:#66d9ef">of</span> <span style="color:#f92672">`</span><span style="color:#66d9ef">&#39;</span>e<span style="color:#f92672">`/`</span><span style="color:#a6e22e">E</span><span style="color:#f92672">`</span> <span style="color:#f92672">-</span> we needed the <span style="color:#f92672">`</span><span style="color:#a6e22e">E</span><span style="color:#f92672">`</span> <span style="color:#66d9ef">to</span>
    <span style="color:#f92672">//</span> satisfy the <span style="color:#f92672">`</span><span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)`</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">of</span> <span style="color:#f92672">`</span><span style="color:#a6e22e">FUNCTOR</span><span style="color:#f92672">`.</span> <span style="color:#a6e22e">In</span> <span style="color:#a6e22e">ReasonML</span><span style="color:#f92672">/</span><span style="color:#a6e22e">OCaml</span><span style="color:#f92672">,</span> functions
    <span style="color:#f92672">//</span> tend <span style="color:#66d9ef">to</span> be <span style="color:#e6db74">&#34;more powerful/polymorphic&#34;</span> than modules <span style="color:#66d9ef">in</span> terms <span style="color:#66d9ef">of</span> dealing
    <span style="color:#f92672">//</span> <span style="color:#66d9ef">with</span> types<span style="color:#f92672">,</span> so we tend <span style="color:#66d9ef">to</span> only have <span style="color:#66d9ef">to</span> <span style="color:#66d9ef">do</span> <span style="color:#66d9ef">module</span> <span style="color:#66d9ef">functor</span> gymnastics <span style="color:#66d9ef">to</span>
    <span style="color:#f92672">//</span> satisfy <span style="color:#66d9ef">module</span> types<span style="color:#f92672">,</span> <span style="color:#f92672">and</span> not so much <span style="color:#66d9ef">for</span> functions<span style="color:#f92672">.</span>

    <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> map<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span></code></pre></div>
<p>In order to actually construct a <code>Functor</code> module for <code>Result</code>, we need to use
the <code>Result.MakeFunctor</code> module functor (the functor functor!), like below:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Error</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">TYPE</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Error1</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Error2</span><span style="color:#f92672">;</span> <span style="color:#f92672">//</span> can be any <span style="color:#66d9ef">type</span>
<span style="color:#f92672">};</span>

<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ResultFunctor</span> <span style="color:#f92672">=</span> Result.<span style="color:#a6e22e">MakeFunctor</span><span style="color:#f92672">(</span><span style="color:#a6e22e">Error</span><span style="color:#f92672">);</span></code></pre></div>
<p>You can also inline the <code>TYPE</code> like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">ResultFunctor</span> <span style="color:#f92672">=</span> Result.<span style="color:#a6e22e">MakeFunctor</span><span style="color:#f92672">({</span> <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">});</span></code></pre></div>
<p>However, you unfortunately can&rsquo;t do things like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">Result.<span style="color:#a6e22e">MakeFunctor</span><span style="color:#f92672">({</span> <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">}).</span>map<span style="color:#f92672">(...);</span></code></pre></div>
<p>At this point you might be wondering why you&rsquo;d even bother creating this
<code>MakeFunctor</code> thing and requiring the <code>TYPE</code> thing having to construct a
special <code>ResultFunctor</code>, when it seems you can just use <code>Result.map</code>
directly. That&rsquo;s a good and valid point, but this post is just trying to set
you up for some more powerful features that become available to you by
creating instances of typeclasses. The point of typeclasses is that they
provide you with a higher-level of abstraction, and provide ways to create
more abstractions on top of them. In a future post, we&rsquo;ll talk about
applicatives and monads, and then hopefully the power, abstraction, and
purpose of this will become more clear.</p>

<h1 id="tree-functor">Tree functor</h1>

<p>Now let&rsquo;s try another data type: a binary tree. Using recursion with <code>map</code>
makes this very similar to <code>list('a)</code>, so I&rsquo;ll just jump into the example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Tree</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Leaf</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">(</span>t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">),</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">));</span>

  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> map <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">,</span> tree<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> switch<span style="color:#f92672">(</span>tree<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Leaf</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Leaf</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">(</span>left<span style="color:#f92672">,</span> <span style="color:#66d9ef">value</span><span style="color:#f92672">,</span> right<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">(</span>map<span style="color:#f92672">(</span>f<span style="color:#f92672">,</span> left<span style="color:#f92672">),</span> f<span style="color:#f92672">(</span><span style="color:#66d9ef">value</span><span style="color:#f92672">),</span> map<span style="color:#f92672">(</span>f<span style="color:#f92672">,</span> right<span style="color:#f92672">))</span>
  <span style="color:#f92672">};</span>

  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Functor</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">type</span> nonrec t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> map<span style="color:#f92672">;</span>
  <span style="color:#f92672">};</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>Our <code>Tree</code> is a variant that&rsquo;s either a <code>Leaf</code> (empty tree), or it&rsquo;s <code>Node</code>
which has a value of type <code>'a</code>, and a sub-tree on the left side, and a
sub-tree on the right side. A tree with one value would be <code>Node(Leaf,
myValue, Leaf)</code>.</p>

<p>The <code>map</code> function just recurses down the left and right branches of the
tree, and the value at each node is updated with <code>f</code>. As you can see we&rsquo;re
not modifying the structure of the tree - just visiting (and updating) the
value at each node with the pure function <code>'a =&gt; 'b</code>.</p>

<h1 id="remotedata-functor">RemoteData functor</h1>

<p>We&rsquo;ve now seen functors for some commonly-used, general data types, but you
can also define functors for more domain-specific types. Let&rsquo;s look at the
Elm
<a href="https://package.elm-lang.org/packages/krisajenkins/remotedata/latest/">RemoteData</a>
type, which also exists as a ReasonML library
<a href="https://github.com/FabienHenon/bs-remotedata">bs-remotedata</a>.</p>

<p>The type in question basically looks like the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">RemoteData</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>e<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">NotAsked</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Loading</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Failure</span><span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>e<span style="color:#f92672">)</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Success</span><span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">);</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>This type is a variant that&rsquo;s used to represent the different states in which
an asynchronous data fetch operation might exist. E.g. the <code>NotAsked</code> state
is typically used as the initial state where there&rsquo;s no data, and a request
has not yet been made. Before the async <code>fetch</code> request is made, the state
might be updated to <code>Loading</code> to indicate that there is work happening. When data
comes in, the state is set to <code>Success('a)</code>, where <code>'a</code> is the data value that
came in, and if the request fails, the state is set to <code>Failure('e)</code> where <code>'e</code>
is the custom error type, which might be a string, or a more specific variant or
record type.</p>

<p>The type is similar to <code>Result.t('a, 'e)</code> in that it has two type parameters,
so the functor implementation is going to look very similar. The <code>NotAsked</code>
and <code>Loading</code> constructors carry no data, so they will just pass through
untouched in the <code>map</code> function. Our map function operates on the
<code>Success('a)</code> channel, so the <code>Failure('e)</code> value will also get passed
through untouched:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">RemoteData</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>e<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Init</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Loading</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Failure</span><span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>e<span style="color:#f92672">)</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Success</span><span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">);</span>

  <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">,</span> remoteData<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> switch<span style="color:#f92672">(</span>remoteData<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Init</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Init</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Loading</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Loading</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Failure</span><span style="color:#f92672">(</span>e<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Failure</span><span style="color:#f92672">(</span>e<span style="color:#f92672">)</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Success</span><span style="color:#f92672">(</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Success</span><span style="color:#f92672">(</span>f<span style="color:#f92672">(</span>a<span style="color:#f92672">))</span>
  <span style="color:#f92672">};</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>To define the <code>FUNCTOR</code> module, we have to use the module functor trick like we did for
<code>Result</code> to lock in the error type. This time I&rsquo;ll show another technique to do this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">RemoteData</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>e<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">...</span>
  <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> <span style="color:#f92672">...</span>

  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">WithError</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">E</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">TYPE</span><span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Functor</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> E.t<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> E.t<span style="color:#f92672">);</span>
      <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> map<span style="color:#f92672">;</span>
    <span style="color:#f92672">};</span>

    <span style="color:#f92672">//</span> <span style="color:#a6e22e">You</span> can use <span style="color:#a6e22e">E</span> <span style="color:#f92672">and</span> E.t <span style="color:#66d9ef">for</span> more things <span style="color:#66d9ef">in</span> here <span style="color:#66d9ef">if</span> you need <span style="color:#66d9ef">to</span><span style="color:#f92672">...</span>
  <span style="color:#f92672">};</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>This time, I&rsquo;m using a <code>WithError</code> module functor that locks in the error
type in <code>E.t</code> and then we define the <code>Functor</code> module within the <code>WithError</code>
module. Doing it this way allows you to use the <code>E</code> error module multiple
times within the same scope without having to functorize every module that
needs to use <code>E</code>. E.g. when we start to add more typeclass instances, it&rsquo;s
handy to just &ldquo;functorize&rdquo; once <code>WithError</code>, and then just define all the
other instances normally with <code>E.t</code>. Beware that module functors are not
without their costs in ocaml (in module purity, dead code elimination, etc.),
so sometimes it&rsquo;s better to use more smaller functors, rather than fewer
larger functors.</p>

<h1 id="custom-data-type-functor">Custom data type functor</h1>

<p>As we&rsquo;ve seen with <code>RemoteData.t('a, 'e)</code> you can define functors for your
own domain types, not just the common data types like <code>list('a)</code>,
<code>option('a)</code>, etc. As you do more functional programming, you&rsquo;ll also start
to see functors used in other new and exciting places, like free monads, etc.</p>

<p>When you&rsquo;re making your own polymorphic types, it&rsquo;s worth thinking about
whether a <code>FUNCTOR</code> (i.e. a <code>map</code> function) might make sense for your data
type. One clue is if your data type has one type parameter that sort of
serves as the &ldquo;main&rdquo; or &ldquo;success&rdquo; value of the type, and the other type
params maybe serve as supporting types. Another clue is whether your type is
a data structure that carries some single type of data - in this case your
type is almost certainly a functor.</p>

<p>You might also find that your data type has multiple values that make sense
to map, and in these cases you might have a <strong>bifunctor</strong>, <strong>trifunctor</strong>,
<strong>quadfunctor</strong>, etc. These are all basically just types that allow you to
map more than one of the polymorphic types, assuming you can still abide by
the functor laws. The rule of thumb with FP is that someone has likely
already figured it out, named it, and fully-implemented it, so if you think
you&rsquo;ve found something interesting, look for prior art.</p>

<h1 id="function-functor">Function functor</h1>

<p>Now let&rsquo;s look at something that&rsquo;s not just a plain old static data type: a
function! Let&rsquo;s consider the function <code>'x =&gt; 'a</code> where <code>'x</code> is some type we
don&rsquo;t really care about, and <code>'a</code> is the type we care about (sort of like in
<code>Result.t('a, 'e)</code> where we cared about the <code>'a</code>, and not so much about the
<code>'e</code> for the purposes of our functor).</p>

<p>Recall the type of <code>map</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> map<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">);</span></code></pre></div>
<p>For our function, we can define our type like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Function</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>x<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>x <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">;</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>Now let&rsquo;s try implementing map:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Function</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>x<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>x <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">;</span>

  <span style="color:#f92672">//</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span>
  <span style="color:#66d9ef">let</span> map<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>x <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>x <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>aToB<span style="color:#f92672">,</span> xToA<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">//</span> <span style="color:#a6e22e">We</span> need <span style="color:#66d9ef">to</span> return a <span style="color:#66d9ef">function</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>x <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> so we know we have an argument
    <span style="color:#f92672">//</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>x<span style="color:#f92672">,</span> <span style="color:#f92672">and</span> a <span style="color:#66d9ef">function</span> from <span style="color:#66d9ef">&#39;</span>x <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#f92672">and</span> a <span style="color:#66d9ef">function</span> from <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> so we
    <span style="color:#f92672">//</span> just call those functions <span style="color:#66d9ef">to</span> convert x <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> b<span style="color:#f92672">:</span>

    x <span style="color:#f92672">=&gt;</span> aToB<span style="color:#f92672">(</span>xToA<span style="color:#f92672">(</span>x<span style="color:#f92672">));</span>
  <span style="color:#f92672">};</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>If you recall above in the functor laws section, we implemented a function
for composing function <code>andThen</code> which looked at lot like this, and there is
also a function called <code>compose</code> which does the same thing, with the
arguments flipped.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> andThen<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>b <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>aToB<span style="color:#f92672">,</span> bToC<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">{</span>
  a <span style="color:#f92672">=&gt;</span> bToC<span style="color:#f92672">(</span>aToB<span style="color:#f92672">(</span>a<span style="color:#f92672">))</span>
<span style="color:#f92672">};</span>

<span style="color:#66d9ef">let</span> <span style="color:#f92672">(&gt;&gt;)</span> <span style="color:#f92672">=</span> andThen<span style="color:#f92672">;</span>

<span style="color:#66d9ef">let</span> compose<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>c<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>bToC<span style="color:#f92672">,</span> aToB<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">{</span>
  a <span style="color:#f92672">=&gt;</span> bToC<span style="color:#f92672">(</span>aToB<span style="color:#f92672">(</span>a<span style="color:#f92672">))</span>
<span style="color:#f92672">};</span>

<span style="color:#66d9ef">let</span> <span style="color:#f92672">(&lt;&lt;)</span> <span style="color:#f92672">=</span> compose<span style="color:#f92672">;</span></code></pre></div>
<p>It turns out the functor for the function <code>'x =&gt; 'a</code> is just the same thing
as function composition!</p>

<p>Now to implement our actual <code>Functor</code> module, we again have to use a module functor
because we&rsquo;re dealing with a type <code>t('x, 'a)</code> which has more than one type parameter.
I&rsquo;ll use the <code>With*</code> module functor trick again, but you could also do this in
the <code>module MakeFunctor = (E: TYPE) =&gt; { type t('a) = ... }</code> style.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Function</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>x<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>x <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">;</span>

  <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>aToB<span style="color:#f92672">,</span> xToA<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> x <span style="color:#f92672">=&gt;</span> aToB<span style="color:#f92672">(</span>xToA<span style="color:#f92672">(</span>x<span style="color:#f92672">));</span>

  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">WithArgument</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">X</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">TYPE</span><span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Functor</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">(</span>X.t<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">(</span>X.t<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">);</span>
      <span style="color:#66d9ef">let</span> map <span style="color:#f92672">=</span> map<span style="color:#f92672">;</span>
    <span style="color:#f92672">};</span>
  <span style="color:#f92672">};</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>If this seems a little silly to you, it is - it&rsquo;s stupid simple, but it turns
out that the function <code>'x =&gt; 'a</code> is actually a very powerful and useful
construct, especially when we get to the topic of monads. If you want to read
ahead, search for <a href="https://www.google.com/search?q=reader+monad">reader
monad</a>.</p>

<h1 id="function-that-s-not-a-covariant-functor">Function that&rsquo;s not a (covariant) functor</h1>

<p>We just looked at the function <code>'x =&gt; 'a</code>, so what about the function <code>'a =&gt;
'x</code>? Let&rsquo;s quickly see if we can implement map for this type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Function</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>x<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>x<span style="color:#f92672">;</span>

  <span style="color:#66d9ef">let</span> map<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>x<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>x<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>aToB<span style="color:#f92672">,</span> aToX<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">//</span> <span style="color:#a6e22e">Need</span> <span style="color:#66d9ef">to</span> return a <span style="color:#66d9ef">function</span> <span style="color:#66d9ef">&#39;</span>b <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>x
    b <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">???</span> huh <span style="color:#f92672">???</span>
  <span style="color:#f92672">};</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>It turns out we can&rsquo;t implement our <code>FUNCTOR</code> for this type. I won&rsquo;t get into
this for now, and hope to in a future blog post, but the reason for this has
to do with <a href="https://en.wikipedia.org/wiki/Functor#Covariance_and_contravariance">covariance vs. contravariance</a>.
The <code>FUNCTOR</code> we defined above with the <code>let map: ('a =&gt; 'b, t('a)) =&gt; t('b)</code> function
is called a <strong>covariant</strong> functor, but the functor that we need for the type <code>'a =&gt; 'x</code>
is called a <strong>contravariant</strong> functor, which looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">CONTRAVARIANT</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">);</span>
  <span style="color:#66d9ef">let</span> contramap<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">);</span> <span style="color:#f92672">//</span> sometimes called cmap
<span style="color:#f92672">};</span></code></pre></div>
<p>If you try to implement <code>CONTRAVARIANT</code> for types like <code>option('a)</code> you&rsquo;re
going to get confused, just like we got confused trying to implement our
covariant <code>FUNCTOR</code> for <code>'a =&gt; 'x</code>. Try implementing <code>CONTRAVARIANT</code> for <code>'a
=&gt; 'x</code> though, and think about function composition again.</p>

<h1 id="parser-decoder-functor">Parser/decoder functor</h1>

<p>So now we&rsquo;ve seen <code>FUNCTOR</code> for <code>'x =&gt; 'a</code> (and mentioned <code>CONTRAVARIANT</code> for
<code>'a =&gt; 'x</code>, but we won&rsquo;t mention <code>CONTRAVARIANT</code> again in this article), so
let&rsquo;s see a real-world example of a covariant <code>FUNCTOR</code> for a function.</p>

<p>What about a function that takes a <code>Js.Json.t</code> value, and &ldquo;decodes&rdquo; it into
a type like <code>Result.t('a, Error.t)</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Decoder</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Error</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">ExpectedString</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Other</span><span style="color:#f92672">;</span>
  <span style="color:#f92672">};</span>

  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Decode</span><span style="color:#f92672">(</span>Js.Json.t <span style="color:#f92672">=&gt;</span> Result.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> Error.t<span style="color:#f92672">));</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>Here our <code>Decoder.t('a)</code> is a data type that wraps a function <code>Js.Json.t =&gt;
Result.t('a, Error.t))</code>. I&rsquo;ll fix the error type for simplicity, but you could
use a polymorphic error if you want (by using the module functor <code>TYPE</code> trick).</p>

<p>If you squint, the function <code>Js.Json.t =&gt; Result.t('a, Error.t))</code> looks a lot
like the function <code>'x =&gt; 'a</code>, where <code>'x</code> is the type we don&rsquo;t really care
about in terms of mapping (the <code>Js.Json.t</code> value), and our <code>'a</code> is just
buried in a <code>Result</code>.</p>

<p>Let&rsquo;s try implementing <code>map</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Decoder</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Error</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">ExpectedString</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Other</span><span style="color:#f92672">;</span>
  <span style="color:#f92672">};</span>

  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Decode</span><span style="color:#f92672">(</span>Js.Json.t <span style="color:#f92672">=&gt;</span> Result.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> Error.t<span style="color:#f92672">));</span>

  <span style="color:#f92672">//</span> <span style="color:#a6e22e">Our</span> map <span style="color:#66d9ef">function</span> needs <span style="color:#66d9ef">to</span> return a <span style="color:#66d9ef">new</span> decoder <span style="color:#f92672">`</span><span style="color:#a6e22e">Decode</span><span style="color:#f92672">(</span>Js.Json.t <span style="color:#f92672">=&gt;</span> Result.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> Error.t<span style="color:#f92672">))`:</span>

  <span style="color:#66d9ef">let</span> map<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>aToB<span style="color:#f92672">,</span> <span style="color:#a6e22e">Decode</span><span style="color:#f92672">(</span>jsonToResultA<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">Decode</span><span style="color:#f92672">(</span>json <span style="color:#f92672">=&gt;</span> jsonToResultA<span style="color:#f92672">(</span>json<span style="color:#f92672">)</span> <span style="color:#f92672">|&gt;</span> Result.map<span style="color:#f92672">(</span>aToB<span style="color:#f92672">));</span>
  <span style="color:#f92672">};</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>Here we&rsquo;re returning a new decode function wrapped in our <code>Decode</code>
constructor. The new function accepts a <code>Js.Json.t</code> argument, and calls our
original decode function to get the <code>Result.t('a, 'e)</code>, then we use the
<code>Result.map</code> function to map the <code>'a</code> value in the <code>Result</code> to the <code>'b</code> value
that we want in the end. Since we&rsquo;re dealing with functions here, nothing has
actually done anything yet - no decoders have been run - we are just left
with a new function that accepts a <code>Js.Json.t</code> and now gives us a
<code>Result.t('b, Error.t)</code>. Stuff like this is where we start to see the real
power of functional programming - just composing pure functions to describe
how to do the work, then doing the work separately.</p>

<p>As a side note, I didn&rsquo;t have to use the <code>Decode</code> wrapper for out <code>t('a)</code> above -
you can just define your type as just an alias for a function like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> Js.Json.t <span style="color:#f92672">=&gt;</span> Result.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> Error.t<span style="color:#f92672">);</span></code></pre></div>
<p>But it&rsquo;s often useful to wrap functions in some type of &ldquo;container&rdquo; or
&ldquo;context&rdquo; and it also helps to envision our decoder as a more opaque
&ldquo;context&rdquo;, rather than just a loose function. You can however do all this
without the wrapper context.</p>

<p>Let&rsquo;s see how this works in reality. We&rsquo;ll implement a boolean decoder, then
map the value to a string:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Decoder</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Error</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span>
      <span style="color:#f92672">|</span> <span style="color:#a6e22e">ExpectedBool</span><span style="color:#f92672">(</span>Js.Json.t<span style="color:#f92672">)</span>
      <span style="color:#f92672">|</span> <span style="color:#a6e22e">OtherError</span><span style="color:#f92672">;</span>
  <span style="color:#f92672">};</span>

  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Decode</span><span style="color:#f92672">(</span>Js.Json.t <span style="color:#f92672">=&gt;</span> Result.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> Error.t<span style="color:#f92672">));</span>

  <span style="color:#66d9ef">let</span> map<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">(</span>aToB<span style="color:#f92672">,</span> <span style="color:#a6e22e">Decode</span><span style="color:#f92672">(</span>jsonToResultA<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span>
      <span style="color:#a6e22e">Decode</span><span style="color:#f92672">(</span>json <span style="color:#f92672">=&gt;</span> jsonToResultA<span style="color:#f92672">(</span>json<span style="color:#f92672">)</span> <span style="color:#f92672">|&gt;</span> Result.map<span style="color:#f92672">(</span>aToB<span style="color:#f92672">));</span>

  <span style="color:#66d9ef">let</span> run<span style="color:#f92672">:</span> <span style="color:#f92672">(</span>Js.Json.t<span style="color:#f92672">,</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> Result.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">,</span> Error.t<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">(</span>json<span style="color:#f92672">,</span> <span style="color:#a6e22e">Decode</span><span style="color:#f92672">(</span>f<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> f<span style="color:#f92672">(</span>json<span style="color:#f92672">);</span>

  <span style="color:#66d9ef">let</span> boolean<span style="color:#f92672">:</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
    <span style="color:#a6e22e">Decode</span><span style="color:#f92672">(</span>
      json <span style="color:#f92672">=&gt;</span>
        switch <span style="color:#f92672">(</span>Js.Json.classify<span style="color:#f92672">(</span>json<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        <span style="color:#f92672">|</span> <span style="color:#a6e22e">JSONTrue</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Ok</span><span style="color:#f92672">(</span>true<span style="color:#f92672">)</span>
        <span style="color:#f92672">|</span> <span style="color:#a6e22e">JSONFalse</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Ok</span><span style="color:#f92672">(</span>false<span style="color:#f92672">)</span>
        <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Error</span><span style="color:#f92672">(</span><span style="color:#a6e22e">ExpectedBool</span><span style="color:#f92672">(</span>json<span style="color:#f92672">))</span>
        <span style="color:#f92672">},</span>
    <span style="color:#f92672">);</span>

  <span style="color:#f92672">//</span> <span style="color:#a6e22e">Define</span> <span style="color:#66d9ef">string</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">float</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">,</span> obj<span style="color:#f92672">,</span> <span style="color:#66d9ef">array</span><span style="color:#f92672">,</span> etc<span style="color:#f92672">.</span> decoders
<span style="color:#f92672">};</span>

Js.log<span style="color:#f92672">(</span>
  Decoder.boolean
  <span style="color:#f92672">|&gt;</span> Decoder.map<span style="color:#f92672">(</span>v <span style="color:#f92672">=&gt;</span> v <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;it was true&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;it was false&#34;</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">|&gt;</span> Decoder.run<span style="color:#f92672">(</span>Js.Json.boolean<span style="color:#f92672">(</span>true<span style="color:#f92672">)),</span>
<span style="color:#f92672">);</span>

Js.log<span style="color:#f92672">(</span>
  Decoder.boolean
  <span style="color:#f92672">|&gt;</span> Decoder.map<span style="color:#f92672">(</span>v <span style="color:#f92672">=&gt;</span> v <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;it was true&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;it was false&#34;</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">|&gt;</span> Decoder.run<span style="color:#f92672">(</span>Js.Json.boolean<span style="color:#f92672">(</span>false<span style="color:#f92672">)),</span>
<span style="color:#f92672">);</span>

Js.log<span style="color:#f92672">(</span>
  Decoder.boolean
  <span style="color:#f92672">|&gt;</span> Decoder.map<span style="color:#f92672">(</span>v <span style="color:#f92672">=&gt;</span> v <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;it was true&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;it was false&#34;</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">|&gt;</span> Decoder.run<span style="color:#f92672">(</span>Js.Json.string<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hi&#34;</span><span style="color:#f92672">)),</span>
<span style="color:#f92672">);</span></code></pre></div>
<p>This logs:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">[</span><span style="color:#e6db74">&#34;it was true&#34;</span><span style="color:#f92672">]</span>
<span style="color:#f92672">[</span><span style="color:#e6db74">&#34;it was false&#34;</span><span style="color:#f92672">]</span>
<span style="color:#f92672">[[</span><span style="color:#e6db74">&#34;hi&#34;</span><span style="color:#f92672">]]</span></code></pre></div>
<p>To break this down:</p>

<ol>
<li>We have our type <code>Decoder.t('a)</code> which is basically a (wrapped) function
from <code>Js.Json.t =&gt; Result.t('a, Error.t)</code></li>
<li>I added a <code>Decoder.run</code> function. Since our decoder is basically a
function, it makes sense that we&rsquo;ll need to call the function at some point,
but passing in a <code>Js.Json.t</code> value to decode. The <code>run</code> function basically
just de-structures our decode function and passes the <code>Js.Json.t</code> value to it
to produce the <code>Result.t('a, Error.t)</code>

<ul>
<li>This is a common pattern in functional programming to build up some
data structure (which might include functions), and provide a way to
&ldquo;run&rdquo; it. Normally, you build up the structure, and then you can pass
around and reuse the the structure (because it&rsquo;s pure, and hasn&rsquo;t
actually done anything yet), and then you just run it when you&rsquo;re ready
for it to do its thing.</li>
</ul></li>
<li>I added a <code>Decoder.boolean</code> function which is a decoder that succeeds if
the given <code>Js.Json.t</code> value is a boolean, and fails if it&rsquo;s not a boolean. 1.
At the bottom, I&rsquo;m setting up my decoder to expect to parse a boolean (using
<code>Decoder.boolean</code>), then I&rsquo;m mapping my <code>Decoder</code> to convert the <code>bool</code> to a
<code>string</code>, then finally, I&rsquo;m running the decoder with a few test values
(<code>true</code>, <code>false</code>, and <code>&quot;hi&quot;</code>), to see what happens. The <code>true</code> and <code>false</code>
cases log the expected strings from the <code>map</code>, and the <code>&quot;hi&quot;</code> case fails.

<ul>
<li>the <code>[[&quot;hi&quot;]]</code> is just the JS representation of my
<code>ExpectedBool(Js.Json.t)</code> error.</li>
</ul></li>
</ol>

<p>You can write other decoders or parsers like this, and do simple things like
parsing a single value and mapping it with a <code>FUNCTOR</code>, but to decode/parse
structures like JSON object and arrays, you&rsquo;ll want to use more powerful
abstractions like <code>Applicative</code> and <code>Monad</code>, which I hope to write a blog
about soon.</p>

<h1 id="future-functor">Future functor</h1>

<p>Let&rsquo;s look at one more real-world example of a <code>FUNCTOR</code> - the <code>Future</code> type
from <a href="https://github.com/RationalJS/future">RationalJS/future</a>.</p>

<p>If you&rsquo;ve done any amount of ReasonML, you&rsquo;ve probably had to deal with
<code>Js.Promise.t('a)</code>, and I suspect you&rsquo;ve not enjoyed it (or maybe you&rsquo;re just
accustomed to the pain if you&rsquo;re coming from JavaScript). I hope to write a
blog in the future about why <code>Js.Promise.t</code> is not great in ReasonML, and
what you should use instead, but for now we&rsquo;ll just look at <code>Future</code> in terms
of implementing <code>FUNCTOR</code>.</p>

<p><code>Future</code> is similar to <code>Js.Promise.t</code> in that it&rsquo;s a async &ldquo;effect&rdquo; type -
it&rsquo;s a data type that represents a computation that will complete sometime in
the future. The
<a href="https://github.com/RationalJS/future/blob/master/src/Future.re">Future</a> type
looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> getFn<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">unit</span><span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">unit</span><span style="color:#f92672">;</span>

<span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Future</span><span style="color:#f92672">(</span>getFn<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">));</span></code></pre></div>
<p><code>getFn</code> might look odd, but all it is is a function that takes a callback <code>'a
=&gt; unit</code> as it&rsquo;s only argument - this callback is often called <code>resolve</code>.</p>

<p>The <code>Future</code> implementation basically creates a function that closes over a
mutable list of &ldquo;subscribers&rdquo;, and when things subscribe to the <code>Future</code>, it
adds those listeners to the array, to be notified when the <code>Future</code> is
resolved.</p>

<p>Let&rsquo;s ignore all that and see if we can just implement <code>map</code> for <code>Future</code>.
Let&rsquo;s pretend that we have a <code>Future.make</code> function that takes our resolver, and
would be used like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">Future.make<span style="color:#f92672">(</span>resolve <span style="color:#f92672">=&gt;</span> Js.Global.setTimeout<span style="color:#f92672">(</span>() <span style="color:#f92672">=&gt;</span> resolve<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hi&#34;</span><span style="color:#f92672">),</span> 40<span style="color:#f92672">));</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Future</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> getFn<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">unit</span><span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">unit</span><span style="color:#f92672">;</span>

  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Future</span><span style="color:#f92672">(</span>getFn<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">));</span>

  <span style="color:#66d9ef">let</span> make <span style="color:#f92672">=</span> <span style="color:#f92672">...;</span>

  <span style="color:#66d9ef">let</span> map<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">(</span>aToB<span style="color:#f92672">,</span> <span style="color:#a6e22e">Future</span><span style="color:#f92672">(</span>onDoneA<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span>
      make<span style="color:#f92672">(</span>resolveB <span style="color:#f92672">=&gt;</span> onDoneA<span style="color:#f92672">(</span>a <span style="color:#f92672">=&gt;</span> resolveB<span style="color:#f92672">(</span>aToB<span style="color:#f92672">(</span>a<span style="color:#f92672">))));</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>I&rsquo;ve changed the <code>map</code> function a little from the real implementation to try
to help with clarity. Basically, the <code>map</code> function takes a <code>Future.t('a)</code>
and waits for that future to be resolved. We are notified when it resolves
via the <code>onDoneA</code> callback. We wrap all this inside a new
<code>Future.make(resolveB =&gt; ...)</code>. <code>resolveB</code> is the function we&rsquo;re supposed to
call when we have a value of type <code>'b</code>. So when we get the <code>'a</code> from
<code>onDoneA</code>, we convert it to <code>'b</code> with our <code>'a =&gt; 'b</code> function and tell the
<code>Future.t('b)</code> that we&rsquo;re done by calling <code>resolveB</code>.</p>

<p>I&rsquo;ll just leave it at that for now, but you can dig in further by cloning the
<a href="https://github.com/RationalJS/future">RationalJS/future</a> repo and trying it
out for yourself.</p>

<p>As a side note, this <code>Future.t('a)</code> differs from <code>Js.Promise.t('a)</code> in that
the <code>Future.t('a)</code> cannot fail - it has no way to represent a failed async
computation. To represent a computation that can fail, you should use
<code>Future.t(Result.t('a, 'e))</code> - in this case your future value is just a type
that can represent both successful and failed computations.</p>

<p>Compared to <code>Js.Promise.t</code>, which hides the error type in some opaque (and
offensive, if you ask me) abstract type, the <code>Future</code> approach makes both the
successful value and the error value &ldquo;first-class&rdquo; - you have full control
over whether and how your async work can fail.</p>

<h1 id="what-can-you-do-with-a-functor">What can you do with a FUNCTOR?</h1>

<p>There are lots of <code>FUNCTOR</code>s in the wild, and you probably use <code>map</code> on a
daily basis, but <code>FUNCTOR</code> is not the most powerful abstraction in the world
of functional programming. You basically use a <code>FUNCTOR</code> when you have some
data structure or context and you want to modify the values inside the
structure/context without affecting the structure itself.</p>

<p>The fact that all a functor knows about is a type <code>t('a)</code> and a <code>map</code>
function is actually a good thing - it gives you a set of well-defined tools
and constraints, but allows you to abstract over those capabilities, and
provides you with a principled baseline on which to create more powerful
abstractions, like <code>Applicative</code>, <code>Monad</code> and all sorts of other stuff.</p>

<h1 id="functor-extensions-and-operators">FUNCTOR extensions and operators</h1>

<p>Higher-level constructs like <code>FUNCTOR</code> let you implement functions from a
higher-level of abstraction. In other words, rather than implementing
map-related functions for each of <code>list('a)</code>, <code>option('a)</code>, <code>Result.t('a,
'e)</code>, etc., we can implement the function once for <code>FUNCTOR</code>, and then all of
the modules we have that have an instance of <code>FUNCTOR</code> get those functions
&ldquo;for free&rdquo;, because these extensions are all implemented just in terms of
<code>FUNCTOR</code> (i.e. <code>t('a)</code> and <code>map</code>).</p>

<p>This is a contrived example, but say you had some data structures like lists,
options, trees, etc., and you needed to convert some data from one type to
another across all these structures. You can setup a <code>FunctorExtensions</code>
module functor that lets you define this function once, and can be used by
anything that has a <code>Functor: FUNCTOR</code> module.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">FunctorExtensions</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">F</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">FUNCTOR</span><span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">let</span> doSomething<span style="color:#f92672">:</span> F.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> F.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> fa <span style="color:#f92672">=&gt;</span> F.map<span style="color:#f92672">(</span>someComplexMappingFunction<span style="color:#f92672">,</span> fa<span style="color:#f92672">);</span>

  <span style="color:#66d9ef">let</span> doAnother<span style="color:#f92672">:</span> F.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> F.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> fa <span style="color:#f92672">=&gt;</span> F.map<span style="color:#f92672">(</span>anotherThing<span style="color:#f92672">,</span> fa<span style="color:#f92672">);</span>

  <span style="color:#f92672">//</span> other stuff<span style="color:#f92672">?</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>This is obviously not super compelling, because you can just use <code>map</code> on
your types, and pass in the mapping functions without this, but it&rsquo;s just an
example of abstracting on <code>FUNCTOR</code>. Also, <code>FUNCTOR</code> is again not a super
powerful abstraction, so the benefits of this will be more clear with things
like <code>Foldable</code> or <code>Monad</code> which I hope to blog about later.</p>

<p>Another use of this <code>FunctorExtension</code> technique is to add some common helper
functions and operators to anything that has a <code>FUNCTOR</code> instance. There are a few common
functions that other FP languages provide for functors:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">FunctorExtensions</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">F</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">FUNCTOR</span><span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">let</span> <span style="color:#f92672">(&lt;$&gt;)</span> <span style="color:#f92672">=</span> F.map<span style="color:#f92672">;</span>

  <span style="color:#66d9ef">let</span> <span style="color:#f92672">(&lt;#&gt;)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>fa<span style="color:#f92672">,</span> f<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> F.map<span style="color:#f92672">(</span>f<span style="color:#f92672">,</span> fa<span style="color:#f92672">);</span>

  <span style="color:#66d9ef">let</span> void<span style="color:#f92672">:</span> F.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> F.t<span style="color:#f92672">(</span><span style="color:#66d9ef">unit</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> fa <span style="color:#f92672">=&gt;</span> F.map<span style="color:#f92672">(_</span> <span style="color:#f92672">=&gt;</span> ()<span style="color:#f92672">,</span> fa<span style="color:#f92672">);</span>

  <span style="color:#66d9ef">let</span> voidLeft<span style="color:#f92672">:</span> <span style="color:#f92672">(</span>F.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">),</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> F.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">(</span>fa<span style="color:#f92672">,</span> b<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> F.map<span style="color:#f92672">(_</span> <span style="color:#f92672">=&gt;</span> b<span style="color:#f92672">,</span> fa<span style="color:#f92672">);</span>

  <span style="color:#66d9ef">let</span> <span style="color:#f92672">($&gt;)</span> <span style="color:#f92672">=</span> voidLeft<span style="color:#f92672">;</span>

  <span style="color:#66d9ef">let</span> voidRight<span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">,</span> F.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> F.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">(</span>b<span style="color:#f92672">,</span> fa<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> F.map<span style="color:#f92672">(_</span> <span style="color:#f92672">=&gt;</span> b<span style="color:#f92672">,</span> fa<span style="color:#f92672">);</span>

  <span style="color:#66d9ef">let</span> <span style="color:#f92672">(&lt;$)</span> <span style="color:#f92672">=</span> voidRight<span style="color:#f92672">;</span>

  <span style="color:#66d9ef">let</span> flap<span style="color:#f92672">:</span> <span style="color:#f92672">(</span>F.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">),</span> <span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> F.t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>fs<span style="color:#f92672">,</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;</span> F.map<span style="color:#f92672">(</span>f <span style="color:#f92672">=&gt;</span> f<span style="color:#f92672">(</span>a<span style="color:#f92672">),</span> fs<span style="color:#f92672">);</span>
<span style="color:#f92672">};</span></code></pre></div>
<p><code>&lt;$&gt;</code> is the operator version of the <code>map</code> function, taken from languages like Haskell.  You use it like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> b<span style="color:#f92672">:</span> option<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> aToB <span style="color:#f92672">&lt;$&gt;</span> <span style="color:#a6e22e">Some</span><span style="color:#f92672">(</span>a<span style="color:#f92672">);</span></code></pre></div>
<p><code>&lt;#&gt;</code> is the flipped version of <code>map</code>, used like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> b<span style="color:#f92672">:</span> option<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Some</span><span style="color:#f92672">(</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;#&gt;</span> aToB<span style="color:#f92672">;</span></code></pre></div>
<p><code>void</code> is a function that basically replaces all the values in your functor
with the <code>unit</code> value <code>()</code>. This is the type of thing that might seem odd,
but you often run into situations where you just need to throw away some data
in FP, or convert a type into something that indicates that you don&rsquo;t care
what it is. <code>void</code> is a commonly-used name in FP for something that &ldquo;clears
out&rdquo; a value by setting it to the <code>unit</code> value <code>()</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> units<span style="color:#f92672">:</span> <span style="color:#66d9ef">list</span><span style="color:#f92672">(</span><span style="color:#66d9ef">unit</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>1<span style="color:#f92672">,</span> 2 <span style="color:#f92672">,</span>3<span style="color:#f92672">]</span> <span style="color:#f92672">|&gt;</span> void<span style="color:#f92672">;</span></code></pre></div>
<p><code>voidLeft</code> is a function that takes a functor of <code>'a</code> and a <code>'b</code> value, and
just sticks the <code>'b</code> value in the functor regardless of what <code>'a</code> value is in
there. <code>$&gt;</code> is the operator version of <code>voidLeft</code>. You can think of the
operator as doing what looks like - half of a <code>&lt;$&gt;</code>/<code>map</code>, but it&rsquo;s just
pointing at the value it&rsquo;s going to use to replace all the values of the
functor. <code>voidLeft</code> is not a great name for this as it&rsquo;s not voiding like
<code>void</code> does, but rather putting a fixed value in, but oh well.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> hi3Times<span style="color:#f92672">:</span> <span style="color:#66d9ef">list</span><span style="color:#f92672">(</span><span style="color:#66d9ef">string</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>1<span style="color:#f92672">,</span> 2 <span style="color:#f92672">,</span>3<span style="color:#f92672">]</span> <span style="color:#f92672">$&gt;</span> <span style="color:#e6db74">&#34;hi&#34;</span><span style="color:#f92672">;</span></code></pre></div>
<p><code>voidRight</code> is the same as <code>voidLeft</code> but with the args flipped. <code>&lt;$</code> is the
operator version of this - you can think of <code>&lt;$</code> similarly to <code>$&gt;</code> - the
arguments are just in the opposite order (i.e. &ldquo;flipped&rdquo;).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> hi3Times<span style="color:#f92672">:</span> <span style="color:#66d9ef">list</span><span style="color:#f92672">(</span><span style="color:#66d9ef">string</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hi&#34;</span> <span style="color:#f92672">&lt;$</span> <span style="color:#f92672">[</span>1<span style="color:#f92672">,</span> 2 <span style="color:#f92672">,</span>3<span style="color:#f92672">];</span></code></pre></div>
<p>Finally, <code>flap</code> is a strange function that takes a functor of functions and a
single value, and applies those functions to the single value to
&ldquo;re-populate&rdquo; the functor with the values produced.</p>

<p>To get access to these extensions, you&rsquo;d do something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Option</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">...;</span>

  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Functor</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">};</span>
  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">FunctorExt</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">FunctorExtensions</span><span style="color:#f92672">(</span><span style="color:#a6e22e">Functor</span><span style="color:#f92672">);</span>

  <span style="color:#f92672">//</span> <span style="color:#a6e22e">Optionally</span> <span style="color:#f92672">`</span><span style="color:#66d9ef">include</span><span style="color:#f92672">`</span> the extensions directly <span style="color:#66d9ef">in</span> your <span style="color:#66d9ef">module</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">include</span> <span style="color:#a6e22e">FunctorExt</span><span style="color:#f92672">;</span>
<span style="color:#f92672">};</span></code></pre></div>
<p>With infix operators, it often best to silo them off into their own module,
suitable for use as a local open.</p>

<p>The extensions and infix technique is used extensively in <code>Relude</code> - see
<a href="https://github.com/reazen/relude/blob/master/src/extensions/Relude_Extensions_Functor.re">Relude_Extensions_Functor</a>
and it&rsquo;s use in
<a href="https://github.com/reazen/relude/blob/master/src/Relude_Option.re">Relude_Option</a>
(both the Extensions and Infix modules), and many other modules.</p>

<h1 id="using-functor-as-a-first-class-module">Using FUNCTOR as a first-class module</h1>

<p>ReasonML/OCaml supports the concept of <a href="https://v1.realworldocaml.org/v1/en/html/first-class-modules.html">first-class
modules</a>,
but I don&rsquo;t believe you can use <a href="https://discuss.ocaml.org/t/higher-kinded-polymorphism/2192">higher-kinded
types</a> like
<code>FUNCTOR</code> in first class modules, so unfortunately, I don&rsquo;t think it&rsquo;s
easy/possible to write a function that expects an arbitrary <code>FUNCTOR</code> as an
argument. There are other techniques (like <a href="https://www.cl.cam.ac.uk/~jdy22/papers/lightweight-higher-kinded-polymorphism.pdf">Lightweight Higher-Kinded
Polymorphism</a>
for encoding higher-kinded types in OCaml, but I&rsquo;m not as familiar with the
techniques described there, so these restrictions might not be true across
the board (or at all!).</p>

<p>As an example, it would be cool if you could do this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">//</span> <span style="color:#a6e22e">This</span> doesn&#39;t work<span style="color:#f92672">,</span> <span style="color:#f92672">or</span> at least <span style="color:#a6e22e">I</span> can&#39;t get it <span style="color:#66d9ef">to</span> work<span style="color:#f92672">!</span>

<span style="color:#66d9ef">let</span> emphasize <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">functor</span><span style="color:#f92672">:</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">FUNCTOR</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">type</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">string</span><span style="color:#f92672">)),</span> fa<span style="color:#f92672">:</span> t<span style="color:#f92672">(</span><span style="color:#66d9ef">string</span><span style="color:#f92672">))</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Functor</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">val</span> <span style="color:#66d9ef">functor</span><span style="color:#f92672">);</span>
  Functor.map<span style="color:#f92672">(</span>a <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">++</span> <span style="color:#e6db74">&#34;!&#34;</span><span style="color:#f92672">,</span> fa<span style="color:#f92672">);</span>
<span style="color:#f92672">};</span>

emphasize<span style="color:#f92672">((</span><span style="color:#66d9ef">module</span> List.<span style="color:#a6e22e">Functor</span><span style="color:#f92672">),</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;goodbye&#34;</span><span style="color:#f92672">]);</span> <span style="color:#f92672">//</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;hello!&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;goodbye!&#34;</span><span style="color:#f92672">]</span> <span style="color:#960050;background-color:#1e0010">ðŸ™</span>
emphasize<span style="color:#f92672">((</span><span style="color:#66d9ef">module</span> Option.<span style="color:#a6e22e">Functor</span><span style="color:#f92672">),</span> <span style="color:#a6e22e">Some</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">));</span>      <span style="color:#f92672">//</span> <span style="color:#a6e22e">Some</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello!&#34;</span><span style="color:#f92672">)</span> <span style="color:#960050;background-color:#1e0010">ðŸ™</span>
emphasize<span style="color:#f92672">((</span><span style="color:#66d9ef">module</span> Result.<span style="color:#a6e22e">Functor</span><span style="color:#f92672">),</span> <span style="color:#a6e22e">Ok</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hi&#34;</span><span style="color:#f92672">));</span>           <span style="color:#f92672">//</span> <span style="color:#a6e22e">Ok</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hi!&#34;</span><span style="color:#f92672">)</span> <span style="color:#960050;background-color:#1e0010">ðŸ™</span></code></pre></div>
<p>Basically create a function that can work on any <code>FUNCTOR</code> without having to
specialize it for each instance, but sadly, I don&rsquo;t think this is possible in
OCaml, because of its lack of higher-kinded types.</p>

<p>This technique does however work for typeclasses that operate on
non-polymorphic types, like <code>TYPE</code>, <code>SHOW</code> or <code>EQ</code> (which will hopefully be
covered in another blog post).</p>

<h1 id="conclusion">Conclusion</h1>

<p>Well, that was an extremely long blog post, but I hope it will help plant
some seeds for someone who might just be starting their FP journey. I hope to
follow-up this post with a blog about <code>Applicatives</code> and then one about
<code>Monads</code>, and then go from there. I want to write these longer fundamental
posts so I have something to refer back to when I want to write smaller blogs
about more focused topics in the future.</p>

<p>I hope you enjoyed! If I don&rsquo;t have comments setup in my blog when you read
this, and you have a comment, feel free to open an issue (or pull request)
here: <a href="https://github.com/andywhite37/blog">https://github.com/andywhite37/blog</a>.</p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
  </section>
</footer>

    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-151733054-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
